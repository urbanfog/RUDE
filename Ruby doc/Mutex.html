<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Class: Mutex
  
    &mdash; Documentation by YARD 0.9.12
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "Mutex";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index (M)</a> &raquo;
    
    
    <span class="title">Mutex</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Class: Mutex
  
  
  
</h1>
<div class="box_info">
  
  <dl>
    <dt>Inherits:</dt>
    <dd>
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">Mutex</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
    </dd>
  </dl>
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>thread_sync.c<span class="defines">,<br />
  thread_sync.c</span>
</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    
<p>Mutex implements a simple semaphore that can be used to coordinate access
to shared data from multiple concurrent threads.</p>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_semaphore'>semaphore</span> <span class='op'>=</span> <span class='const'>Mutex</span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Mutex#initialize (method)">new</a></span></span>

<span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Thread.html" title="Thread (class)">Thread</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="Thread.html#new-class_method" title="Thread.new (method)">new</a></span></span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_semaphore'>semaphore</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span>
    <span class='comment'># access shared resource
</span>  <span class='rbrace'>}</span>
<span class='rbrace'>}</span>

<span class='id identifier rubyid_b'>b</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Thread.html" title="Thread (class)">Thread</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="Thread.html#new-class_method" title="Thread.new (method)">new</a></span></span> <span class='lbrace'>{</span>
  <span class='id identifier rubyid_semaphore'>semaphore</span><span class='period'>.</span><span class='id identifier rubyid_synchronize'>synchronize</span> <span class='lbrace'>{</span>
    <span class='comment'># access shared resource
</span>  <span class='rbrace'>}</span>
<span class='rbrace'>}</span>
</code></pre>


  </div>
</div>
<div class="tags">
  

</div>






  
    <h2>
      Instance Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#new (instance method)">#<strong>new</strong>  &#x21d2; Object </a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Creates a new Mutex.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lock-instance_method" title="#lock (instance method)">#<strong>lock</strong>  &#x21d2; self </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Attempts to grab the lock and waits if it isn&#39;t available.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#locked%3F-instance_method" title="#locked? (instance method)">#<strong>locked?</strong>  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns <code>true</code> if this lock is currently held by some thread.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#owned%3F-instance_method" title="#owned? (instance method)">#<strong>owned?</strong>  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Returns <code>true</code> if this lock is currently held by current thread.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sleep-instance_method" title="#sleep (instance method)">#<strong>sleep</strong>(timeout = nil)  &#x21d2; Numeric </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Releases the lock and sleeps <code>timeout</code> seconds if it is given
and non-nil or forever.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#synchronize-instance_method" title="#synchronize (instance method)">#<strong>synchronize</strong> { ... } &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Obtains a lock, runs the block, and releases the lock when the block
completes.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_lock-instance_method" title="#try_lock (instance method)">#<strong>try_lock</strong>  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Attempts to obtain the lock and returns immediately.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#unlock-instance_method" title="#unlock (instance method)">#<strong>unlock</strong>  &#x21d2; self </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Releases the lock.</p>
</div></span>
  
</li>

      
    </ul>
  

<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    #<strong>new</strong>  &#x21d2; <tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Creates a new Mutex</p>


  </div>
</div>
<div class="tags">
  
  


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


154
155
156
157
158</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'thread_sync.c', line 154</span>

static VALUE
mutex_initialize(VALUE self)
{
    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="lock-instance_method">
  
    #<strong>lock</strong>  &#x21d2; <tt>self</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Attempts to grab the lock and waits if it isn&#39;t available. Raises
<code>ThreadError</code> if <code>mutex</code> was locked by the current
thread.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>self</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'thread_sync.c', line 231</span>

VALUE
rb_mutex_lock(VALUE self)
{
    rb_thread_t *th = GET_THREAD();
    rb_mutex_t *mutex;
    GetMutexPtr(self, mutex);

    /* When running trap handler */
    if (!FL_TEST_RAW(self, MUTEX_ALLOW_TRAP) &amp;&amp;
	th-&gt;ec-&gt;interrupt_mask &amp; TRAP_INTERRUPT_MASK) {
	rb_raise(rb_eThreadError, &quot;can&#39;t be called from trap context&quot;);
    }

    if (rb_mutex_trylock(self) == Qfalse) {
	struct sync_waiter w;

	if (mutex-&gt;th == th) {
	    rb_raise(rb_eThreadError, &quot;deadlock; recursive locking&quot;);
	}

	w.th = th;

	while (mutex-&gt;th != th) {
	    enum rb_thread_status prev_status = th-&gt;status;
	    struct timespec *timeout = 0;
	    struct timespec ts = { 0, 100000000 }; /* 100ms */

	    th-&gt;status = THREAD_STOPPED_FOREVER;
	    th-&gt;locking_mutex = self;
	    th-&gt;vm-&gt;sleeper++;
	    /*
	     * Carefully! while some contended threads are in native_sleep(),
	     * vm-&gt;sleeper is unstable value. we have to avoid both deadlock
	     * and busy loop.
	     */
	    if ((vm_living_thread_num(th-&gt;vm) == th-&gt;vm-&gt;sleeper) &amp;&amp;
		!patrol_thread) {
		timeout = &amp;ts;
		patrol_thread = th;
	    }

	    list_add_tail(&amp;mutex-&gt;waitq, &amp;w.node);
	    native_sleep(th, timeout); /* release GVL */
	    list_del(&amp;w.node);
	    if (!mutex-&gt;th) {
		mutex-&gt;th = th;
	    }

	    if (patrol_thread == th)
		patrol_thread = NULL;

	    th-&gt;locking_mutex = Qfalse;
	    if (mutex-&gt;th &amp;&amp; timeout &amp;&amp; !RUBY_VM_INTERRUPTED(th-&gt;ec)) {
		rb_check_deadlock(th-&gt;vm);
	    }
	    if (th-&gt;status == THREAD_STOPPED_FOREVER) {
		th-&gt;status = prev_status;
	    }
	    th-&gt;vm-&gt;sleeper--;

	    if (mutex-&gt;th == th) mutex_locked(th, self);

	    RUBY_VM_CHECK_INTS_BLOCKING(th-&gt;ec);
	}
    }
    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="locked?-instance_method">
  
    #<strong>locked?</strong>  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns <code>true</code> if this lock is currently held by some thread.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


172
173
174
175
176
177
178</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'thread_sync.c', line 172</span>

VALUE
rb_mutex_locked_p(VALUE self)
{
    rb_mutex_t *mutex;
    GetMutexPtr(self, mutex);
    return mutex-&gt;th ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="owned?-instance_method">
  
    #<strong>owned?</strong>  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Returns <code>true</code> if this lock is currently held by current thread.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


305
306
307
308
309
310
311
312
313
314
315
316
317
318</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'thread_sync.c', line 305</span>

VALUE
rb_mutex_owned_p(VALUE self)
{
    VALUE owned = Qfalse;
    rb_thread_t *th = GET_THREAD();
    rb_mutex_t *mutex;

    GetMutexPtr(self, mutex);

    if (mutex-&gt;th == th)
	owned = Qtrue;

    return owned;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="sleep-instance_method">
  
    #<strong>sleep</strong>(timeout = nil)  &#x21d2; <tt><span class='object_link'><a href="Numeric.html" title="Numeric (class)">Numeric</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Releases the lock and sleeps <code>timeout</code> seconds if it is given
and non-nil or forever.  Raises <code>ThreadError</code> if
<code>mutex</code> wasn&#39;t locked by the current thread.</p>

<p>When the thread is next woken up, it will attempt to reacquire the lock.</p>

<p>Note that this method can wakeup without explicit Thread#wakeup call. For
example, receiving signal and so on.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Numeric.html" title="Numeric (class)">Numeric</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


473
474
475
476
477
478
479
480</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'thread_sync.c', line 473</span>

static VALUE
mutex_sleep(int argc, VALUE *argv, VALUE self)
{
    VALUE timeout;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;timeout);
    return rb_mutex_sleep(self, timeout);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="synchronize-instance_method">
  
    #<strong>synchronize</strong> { ... } &#x21d2; <tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Obtains a lock, runs the block, and releases the lock when the block
completes.  See the example under <code>Mutex</code>.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Yields:</p>
<ul class="yield">
  
    <li>
      
      
        <span class='type'></span>
      
      
      
        
        <div class='inline'><dl class="rdoc-list label-list"><dt>
<dd></dd></dl>
</div>
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


504
505
506
507
508
509
510
511
512</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'thread_sync.c', line 504</span>

static VALUE
rb_mutex_synchronize_m(VALUE self, VALUE args)
{
    if (!rb_block_given_p()) {
	rb_raise(rb_eThreadError, &quot;must be called with a block&quot;);
    }

    return rb_mutex_synchronize(self, rb_yield, Qundef);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_lock-instance_method">
  
    #<strong>try_lock</strong>  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Attempts to obtain the lock and returns immediately. Returns
<code>true</code> if the lock was granted.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'thread_sync.c', line 199</span>

VALUE
rb_mutex_trylock(VALUE self)
{
    rb_mutex_t *mutex;
    VALUE locked = Qfalse;
    GetMutexPtr(self, mutex);

    if (mutex-&gt;th == 0) {
	rb_thread_t *th = GET_THREAD();
	mutex-&gt;th = th;
	locked = Qtrue;

	mutex_locked(th, self);
    }

    return locked;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="unlock-instance_method">
  
    #<strong>unlock</strong>  &#x21d2; <tt>self</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Releases the lock. Raises <code>ThreadError</code> if <code>mutex</code>
wasn&#39;t locked by the current thread.</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>self</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>


</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


369
370
371
372
373
374
375
376
377
378
379
380</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'thread_sync.c', line 369</span>

VALUE
rb_mutex_unlock(VALUE self)
{
    const char *err;
    rb_mutex_t *mutex;
    GetMutexPtr(self, mutex);

    err = rb_mutex_unlock_th(mutex, GET_THREAD());
    if (err) rb_raise(rb_eThreadError, &quot;%s&quot;, err);

    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Mon Feb 26 22:23:27 2018 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.12 (ruby-2.4.2).
</div>

    </div>
  </body>
</html>